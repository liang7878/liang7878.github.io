---
title: 读《C++并发编程实战 -- C++ Concurrency In Action》
tags:
  - C++
  - CPP
  - 编程进阶
  - 并发编程
abbrlink: 836781f0
date: 2023-08-15 20:24:43
---

## C++ 并发编程基础

### 什么是并发

并发（concurrency）：把任务在不同的时间点交给处理器进行处理。在同一时间点，任务并不会同时运行。

并行（parallelism）：把每一个任务分配给每一个处理器独立完成。在同一时间点，任务一定是同时运行。

并发的方式包括多进程并发和多线程并发，多进程并发通过进程间通信（信号、套接字、文件、管道等）来相互传递信息；由于同一进程内的所有线程都共用相同的地址空间，所以多进程并发通过共享内存来同步数据。

<!--more-->

并发技术可以：

1. 分离关注点（separation of concerns），使得不同的线程关注不同的任务；
2. 提升性能。任务并行可以采取两种方式，一种是将单一任务分成多个部分，各自并行运作，从而节省总运行耗时；第二种是利用并行资源解决规模更大的问题。

什么时候避免并发？

1. 并发会增加额外的复杂度，增加开发时间和维护成本
2. 多线程的性能增幅可能不如预期，因为线程的启动会有额外的时间开销
3. 线程是一种有限的资源，过多的线程会消耗系统资源，从而导致系统整体变慢
4. 运行的线程越多，操作系统的上下文切换就越频繁，上下文切换会减少本该用于实质工作的时间

我们先尝试一个简单的多线程版本的 `Hello World`

```cpp
#include <iostream>
#include <thread>

using namespace std;

void hello() {
    cout << "Hello Concurrent World\n";
}

int main(){
    thread t(hello);
    t.join();
}
```

## 线程管控

线程的管控可以通过 std::thread 对象来实现。

悬空引用（Dangling Reference）是指一个引用在指向有效数据之后，被引用的数据被销毁或释放，从而引用变成了无效的情况。这种情况可能导致程序运行时的未定义行为，因为引用指向的数据已经不存在，但程序仍试图通过该引用访问这个不存在的数据。如果新线程上的函数持有指针或引用，指向主线程的局部变量；但主线程所运行的函数退出后，新线程却还没结束，这时就会访问悬空引用的情况。

上述情况的处理办法是令线程函数完全自含（self-contained），将数据复制到新线程内部，而不是共享数据。另一种方法是汇合新线程，确保主线程的函数退出前，新线程执行完毕。

等待线程完成可调用成员函数`join()`来实现。在`std::thread`对象销毁前，我们需确保已经调用`join()`或`detach()`.假使打算等待线程结束，则需小心地选择执行代码的位置来调用join()。原因是，如果线程启动以后主线程有异常抛出，而join()尚未执行，则该join()调用会被略过。

用`std::thread`对象的成员函数`detach()`，会令线程在后台运行，遂无法与之直接通信。假若线程被分离，就无法等待它完结，也不可能获得与它关联的std::thread对象，因而无法汇合该线程。然而分离的线程确实仍在后台运行，其归属权和控制权都转移给C++运行时库（runtime library，又名运行库），由此保证，一旦线程退出，与之关联的资源都会被正确回收。

线程具有内部存储空间，参数会按照默认方式先复制到该处，新创建的执行线程才能直接访问它们。然后，这些副本被当成临时变量，以右值[4]形式传给新线程上的函数或可调用对象。即便函数的相关参数按设想应该是引用，上述过程依然会发生。

只要`std::thread`对象正管控着一个线程，就不能简单地向它赋新值，否则该线程会因此被遗弃。

线程ID所属型别是`std::thread::id`，它有两种获取方法。首先，在与线程关联的`std::thread`对象上调用成员函数`get_id()`，即可得到该线程的ID。如果`std::thread`对象没有关联任何执行线程，调用`get_id()`则会返回一个`std::thread::id`对象，它按默认构造方式生成，表示“线程不存在”。其次，当前线程的ID可以通过调用`std::this_thread::get_id()`获得，函数定义位于头文件<thread>内。

## 在线程间共享数据

归根结底，多线程共享数据的问题多由数据改动引发。如果所有共享数据都是只读数据，就不会有问题。

“数据竞争”（data race）：并发改动单个对象而形成的特定的条件竞争。诱发恶性条件竞争的典型场景是，要完成一项操作，却需改动两份或多份不同的数据，如上例中的两个链接指针。

如何防止恶性竞争？最简单的就是采取保护措施包装数据结构，确保不变量被破坏时，中间状态只对执行改动的线程可见；另一种方法是，修改数据结构的设计及其不变量，由一连串不可拆分的改动完成数据变更，每个改动都维持不变量不被破坏。这通常被称为无锁编程，难以正确编写；还有一种防止恶性条件竞争的方法，将修改数据结构当作事务（transaction）来处理，类似于数据库在一个事务内完成更新：把需要执行的数据读写操作视为一个完整序列，先用事务日志存储记录，再把序列当成单一步骤提交运行。若别的线程改动了数据而令提交无法完整执行，则事务重新开始。这称为软件事务内存（Software Transactional Memory，STM）。

在C++标准中，保护共享数据的最基本方式就是互斥。C++标准库提供了类模板`std::lock_guard<>`，针对互斥类融合实现了RAII手法：在构造时给互斥加锁，在析构时解锁，从而保证互斥总被正确解锁。

防范死锁的建议通常是，始终按相同顺序对两个互斥加锁。

C++17还进一步提供了新的RAII类模板std::scoped_lock<>。std:: scoped_lock<>和std::lock_guard<>完全等价，只不过前者是可变参数模板（variadic template），接收各种互斥型别作为模板参数列表，还以多个互斥对象作为构造函数的参数列表。

防范死锁的补充准则：

- 避免嵌套锁
- 一旦持锁，就须避免调用由用户提供的程序借口
- 依从固定顺序获取锁
- 按层级枷锁
- 将准则推广到锁操作以外

锁操作有两个要点：一是选择足够粗大的锁粒度，确保目标数据受到保护；二是限制范围，务求只在必要的操作过程中持锁。一般地，若要执行某项操作，那我们应该只在所需的最短时间内持锁

## 并发操作的同步

如何等待事件或者其他条件？

- 方式一：在共享数据内部维护一标志（受互斥保护），线程乙完成任务后，就设置标志成立。（条件变量）
- 方式二：让线程甲调用`std::this_thread::sleep_for()`函数，在各次查验之间短期休眠
- 方式三：使用C++标准库的工具等待事件发生

C++标准程序库使用future来模拟一次性事件：若线程需等待某个特定的一次性事件发生，则会以恰当的方式取得一个future，它代表目标事件；接着，该线程就能一边执行其他任务（光顾机场茶座），一边在future上等待；同时，它以短暂的间隔反复查验目标事件是否已经发生（查看出发时刻表）

## C++内存模型和原子操作

### C++内存模型

每个变量都是对象，对象的数据成员也是对象；每个对象都占用至少一块内存区域；若变量属于内建基本类型（如int或char），则不论其大小，都占用一块内存区域（且仅此一块），即便它们的位置相邻或它们是数列中的元素；相邻的位域属于同一内存区域。

原子操作是不可分割的操作（indivisible operation）。在系统的任一线程内，我们都不会观察到这种操作处于半完成状态；它或者完全做好，或者完全没做。

标准原子类型的定义位于头文件<atomic>内。

### C++标准库提供的原子操作

### 如何利用以上操作实现线程间同步

## 设计基于锁的并发数据结构

## 设计无锁数据结构

## 设计并发代码

## 高级线程管理

## 并行算法函数

## 多线程应用的测试和除错
